O(1)

int a = 5;
int b = 7;
int c = 4;
int d = a + b + c + 153;


O(n)

for (int i = 1; i <= n; i++) {
}

int i = 0;
while (i < n) {
	i++;
}


O(n*m)

for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= m; j++) {
		// constant time code here
	}
}


O(n^2)

for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= n; j++) {
		// constant time code here
	}
}
for (int i = 1; i <= n + 58834; i++) {
	// more constant time code here
}

Input base rules 
>> n <= 10 - O(n!), O(n^7)..
>> n <= 20 - O(2^n*n), O(n^5)
>> n <= 80 - O(n^4) 
>> n <= 400 - O(n^3)
>> n <= 7500 - O(n^2)
>> n <= 7 * 10^4 - O(n*sqrt(n))
>> n <= 5*10^5 - O(n*log(n))
>> n <= 5*10^6 - O(n)
>> n <= 10^18 - O(log(n)^2), O(log(n)), O(1)


Constant factor refers to the idea that different operations with the same
complexity take slightly different amounts of time to run. For example, three
addition operations take a bit longer than a single addition operation. Another
example is that although binary search on an array and insertion into an ordered
set are both O(log n), binary search is noticeably faster.

Constant factor is entirely ignored in Big O notation. This is fine most of
the time, but if the time limit is particularly tight, you may receive time
limit exceeded (TLE) with the intended complexity. When this happens, it is
important to keep the constant factor in mind. For example, a piece of code that
iterates through all ordered triplets runs in O(n^3) time might be
sped up by a factor of $6$ if we only need to iterate through all unordered
triplets.